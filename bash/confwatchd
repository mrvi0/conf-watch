#!/usr/bin/env bash

# ConfWatch Daemon - Automatic Configuration File Monitor
# Uses bash-lib for colored output, logging, and validation

# Load bash-lib library
source <(curl -fsSL https://raw.githubusercontent.com/mrvi0/bash-lib/main/bash-lib-standalone.sh)

# Configuration
CONFWATCH_HOME="$HOME/.confwatch"
CONFIG_FILE="$CONFWATCH_HOME/config/config.yml"
REPO_DIR="$CONFWATCH_HOME/repo"
PID_FILE="$CONFWATCH_HOME/confwatchd.pid"
LOG_FILE="$CONFWATCH_HOME/confwatchd.log"

# Daemon status
DAEMON_RUNNING=false

# Initialize daemon
init_daemon() {
    logging::info "Initializing ConfWatch daemon"
    
    # Check if ConfWatch is installed
    if [[ ! -d "$CONFWATCH_HOME" ]]; then
        colors::error "ConfWatch is not installed. Run ./install.sh first."
        exit 1
    fi
    
    # Check if config exists
    if [[ ! -f "$CONFIG_FILE" ]]; then
        colors::error "Configuration file not found: $CONFIG_FILE"
        exit 1
    fi
    
    # Check if repo exists
    if [[ ! -d "$REPO_DIR" ]]; then
        colors::error "Repository directory not found: $REPO_DIR"
        exit 1
    fi
    
    # Create log directory
    mkdir -p "$(dirname "$LOG_FILE")"
    
    colors::success "Daemon initialized successfully"
}

# Check if daemon is running
check_daemon_status() {
    if [[ -f "$PID_FILE" ]]; then
        local pid=$(cat "$PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            DAEMON_RUNNING=true
            return 0
        else
            # Remove stale PID file
            rm -f "$PID_FILE"
            DAEMON_RUNNING=false
            return 1
        fi
    fi
    DAEMON_RUNNING=false
    return 1
}

# Start daemon
start_daemon() {
    logging::info "Starting ConfWatch daemon"
    
    if check_daemon_status; then
        colors::warning "Daemon is already running (PID: $(cat "$PID_FILE"))"
        return 1
    fi
    
    # Start daemon in background
    nohup "$0" monitor > "$LOG_FILE" 2>&1 &
    local pid=$!
    
    # Save PID
    echo "$pid" > "$PID_FILE"
    
    colors::success "Daemon started with PID: $pid"
    logging::info "Daemon PID saved to: $PID_FILE"
    logging::info "Log file: $LOG_FILE"
}

# Stop daemon
stop_daemon() {
    logging::info "Stopping ConfWatch daemon"
    
    if ! check_daemon_status; then
        colors::warning "Daemon is not running"
        return 1
    fi
    
    local pid=$(cat "$PID_FILE")
    
    # Send SIGTERM
    kill "$pid" 2>/dev/null
    
    # Wait for graceful shutdown
    local count=0
    while kill -0 "$pid" 2>/dev/null && [[ $count -lt 10 ]]; do
        sleep 1
        count=$((count + 1))
    done
    
    # Force kill if still running
    if kill -0 "$pid" 2>/dev/null; then
        kill -9 "$pid" 2>/dev/null
        colors::warning "Daemon force killed"
    else
        colors::success "Daemon stopped gracefully"
    fi
    
    # Remove PID file
    rm -f "$PID_FILE"
    logging::info "Daemon stopped and PID file removed"
}

# Show daemon status
show_status() {
    if check_daemon_status; then
        local pid=$(cat "$PID_FILE")
        colors::success "Daemon is running (PID: $pid)"
        
        # Show uptime
        local uptime=$(ps -o etime= -p "$pid" 2>/dev/null)
        if [[ -n "$uptime" ]]; then
            colors::info "Uptime: $uptime"
        fi
        
        # Show recent logs
        if [[ -f "$LOG_FILE" ]]; then
            echo ""
            colors::info "Recent logs:"
            tail -n 10 "$LOG_FILE"
        fi
    else
        colors::error "Daemon is not running"
    fi
}

# Monitor files for changes
monitor_files() {
    logging::info "Starting file monitoring"
    
    # Set up logging for monitor process
    logging::set_file "$LOG_FILE"
    logging::set_level info
    
    # Get monitoring interval from config (default: 300 seconds)
    local interval=300
    if command -v yq &> /dev/null; then
        interval=$(yq e '.monitoring.interval // 300' "$CONFIG_FILE" 2>/dev/null)
    fi
    
    logging::info "Monitoring interval: ${interval}s"
    
    # Main monitoring loop
    while true; do
        logging::debug "Starting monitoring cycle"
        
        # Read config file and extract watch list
        local files=$(grep "^- " "$CONFIG_FILE" | sed 's/^- //' | sed 's/^[[:space:]]*//')
        
        for file in $files; do
            # Expand tilde in path
            local expanded_file=$(eval echo "$file")
            
            # Check if file exists
            if [[ ! -f "$expanded_file" ]]; then
                logging::debug "File not found: $expanded_file"
                continue
            fi
            
            # Get absolute path
            local abs_file=$(realpath "$expanded_file")
            local basename=$(basename "$abs_file")
            local repo_file="$REPO_DIR/$basename"
            
            # Check if file has changed
            if [[ -f "$repo_file" ]]; then
                if ! cmp -s "$abs_file" "$repo_file"; then
                    logging::info "Change detected in: $file"
                    
                    # Create snapshot
                    cd "$REPO_DIR"
                    cp "$abs_file" "$repo_file"
                    git add "$basename" > /dev/null 2>&1
                    
                    if ! git diff --cached --quiet; then
                        local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
                        git commit -m "Auto-snapshot: $file at $timestamp" > /dev/null 2>&1
                        logging::info "Auto-snapshot created for: $file"
                        
                        # Send notification if configured
                        send_notification "$file" "$timestamp"
                    fi
                fi
            else
                # First time seeing this file
                logging::info "New file detected: $file"
                cd "$REPO_DIR"
                cp "$abs_file" "$repo_file"
                git add "$basename" > /dev/null 2>&1
                local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
                git commit -m "Initial snapshot: $file at $timestamp" > /dev/null 2>&1
                logging::info "Initial snapshot created for: $file"
            fi
        done
        
        # Sleep for monitoring interval
        sleep "$interval"
    done
}

# Send notification
send_notification() {
    local file="$1"
    local timestamp="$2"
    
    # Check if Telegram notifications are enabled
    if command -v yq &> /dev/null; then
        local telegram_enabled=$(yq e '.notifications.telegram.enabled // false' "$CONFIG_FILE" 2>/dev/null)
        local bot_token=$(yq e '.notifications.telegram.bot_token // ""' "$CONFIG_FILE" 2>/dev/null)
        local chat_id=$(yq e '.notifications.telegram.chat_id // ""' "$CONFIG_FILE" 2>/dev/null)
        
        if [[ "$telegram_enabled" == "true" ]] && [[ -n "$bot_token" ]] && [[ -n "$chat_id" ]]; then
            local message="ðŸ”„ ConfWatch: Change detected in $file at $timestamp"
            
            if command -v curl &> /dev/null; then
                curl -s -X POST "https://api.telegram.org/bot$bot_token/sendMessage" \
                    -d "chat_id=$chat_id" \
                    -d "text=$message" \
                    -d "parse_mode=HTML" > /dev/null 2>&1
                
                logging::info "Telegram notification sent"
            fi
        fi
    fi
}

# Show help
show_help() {
    print_header "ConfWatch Daemon Help"
    
    echo -e "${CYAN}Usage:${NC}"
    echo "  confwatchd <command>"
    echo ""
    
    echo -e "${CYAN}Commands:${NC}"
    echo "  start               Start the daemon"
    echo "  stop                Stop the daemon"
    echo "  restart             Restart the daemon"
    echo "  status              Show daemon status"
    echo "  monitor             Run monitoring (internal use)"
    echo "  help                Show this help"
    echo ""
    
    echo -e "${CYAN}Examples:${NC}"
    echo "  confwatchd start"
    echo "  confwatchd status"
    echo "  confwatchd stop"
    echo ""
    
    echo -e "${CYAN}Files:${NC}"
    echo "  PID file: $PID_FILE"
    echo "  Log file: $LOG_FILE"
    echo "  Config: $CONFIG_FILE"
}

# Main function
main() {
    # Initialize
    init_daemon
    
    # Parse command line arguments
    local command="$1"
    
    case "$command" in
        "start")
            start_daemon
            ;;
        "stop")
            stop_daemon
            ;;
        "restart")
            stop_daemon
            sleep 2
            start_daemon
            ;;
        "status")
            show_status
            ;;
        "monitor")
            monitor_files
            ;;
        "help"|"--help"|"-h")
            show_help
            ;;
        "")
            show_help
            ;;
        *)
            colors::error "Unknown command: $command"
            echo ""
            show_help
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@" 